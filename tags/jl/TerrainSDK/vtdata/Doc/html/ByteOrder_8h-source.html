<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ByteOrder.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.9.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>ByteOrder.h</h1><div class="fragment"><pre>00001 <font class="comment">//</font>
00002 <font class="comment">// ByteOrder.h</font>
00003 <font class="comment">//</font>
00004 <font class="comment">// Copyright (c) 2001 Virtual Terrain Project</font>
00005 <font class="comment">// Free for all uses, see license.txt for details.</font>
00006 <font class="comment">//</font>
00007 
00008 <font class="preprocessor">#ifndef BYTEORDERH</font>
00009 <font class="preprocessor"></font><font class="preprocessor">#define BYTEORDERH</font>
00010 <font class="preprocessor"></font>
00011 <font class="preprocessor">#include &lt;stdio.h&gt;</font>
00012 <font class="preprocessor">#include &lt;assert.h&gt;</font>
00013 
00014 <font class="keyword">enum</font> ByteOrder
00015 {
00016     BO_LITTLE_ENDIAN,                   <font class="comment">/*  Intel  */</font>
00017     BO_BIG_ENDIAN,                      <font class="comment">/*  Motorola, MIPS, Sun, etc.  */</font>
00018     BO_MACHINE,
00019   BO_LE  = BO_LITTLE_ENDIAN,
00020   BO_BE  = BO_BIG_ENDIAN,
00021   BO_CPU = BO_MACHINE
00022 };
00023 
00024 <font class="keyword">enum</font> DataType
00025 {
00026     DT_SHORT, DT_INT, DT_LONG, DT_FLOAT, DT_DOUBLE
00027 };
00028 
00032 <font class="keyword">inline</font> ByteOrder NativeByteOrder( <font class="keywordtype">void</font> )<font class="keyword"></font>
00033 <font class="keyword"></font>{
00034     <font class="keyword">static</font> <font class="keywordtype">int</font> iByteOrderTest = 0x1;
00035 
00036     <font class="keywordflow">if</font> ( *((<font class="keywordtype">char</font> *) &amp;iByteOrderTest) == 0x1 )
00037         <font class="keywordflow">return</font> BO_LITTLE_ENDIAN;
00038     <font class="keywordflow">else</font>
00039         <font class="keywordflow">return</font> BO_BIG_ENDIAN;
00040 }
00041 
00042 <font class="comment">/*</font>
00043 <font class="comment"> * Various macros that always swap byte order.  Expanded in-line for</font>
00044 <font class="comment"> *   maximum speed when processing arrays.</font>
00045 <font class="comment"> *</font>
00046 <font class="comment"> */</font>
00047 <font class="keyword">inline</font> <font class="keywordtype">short</font> SwapShort( <font class="keywordtype">short</font> data )<font class="keyword"></font>
00048 <font class="keyword"></font>{
00049     assert( <font class="keyword">sizeof</font>(<font class="keywordtype">short</font>) == 2 );
00050     <font class="keywordflow">return</font> (data &lt;&lt; 8) | (data &gt;&gt; 8);
00051 }
00052 <font class="keyword">inline</font> <font class="keywordtype">long</font> SwapLong( <font class="keywordtype">long</font> data )<font class="keyword"></font>
00053 <font class="keyword"></font>{
00054     assert( <font class="keyword">sizeof</font>(<font class="keywordtype">long</font>) == 4 );
00055     <font class="keywordflow">return</font> ( data &lt;&lt; 24 )                 | (( data &lt;&lt; 8 ) &amp; 0x00FF0000 ) |
00056            (( data &gt;&gt; 24 ) &amp; 0x000000FF ) | (( data &gt;&gt; 8 ) &amp; 0x0000FF00 );
00057 }
00058 <font class="keyword">inline</font> <font class="keywordtype">int</font> SwapInt( <font class="keywordtype">int</font> data )<font class="keyword"></font>
00059 <font class="keyword"></font>{
00060     assert( <font class="keyword">sizeof</font>(<font class="keywordtype">int</font>) == <font class="keyword">sizeof</font>(<font class="keywordtype">short</font>) || <font class="keyword">sizeof</font>(<font class="keywordtype">int</font>) == <font class="keyword">sizeof</font>(<font class="keywordtype">long</font>) );
00061     <font class="keywordflow">if</font> ( <font class="keyword">sizeof</font>(<font class="keywordtype">int</font>) == <font class="keyword">sizeof</font>(<font class="keywordtype">short</font>) )
00062         <font class="keywordflow">return</font> SwapShort( (<font class="keywordtype">short</font>)data );
00063     <font class="keywordflow">else</font>
00064         <font class="keywordflow">return</font> SwapLong( (<font class="keywordtype">long</font>)data );
00065 }
00066 <font class="keyword">inline</font> <font class="keywordtype">float</font> SwapFloat( <font class="keywordtype">float</font> data )<font class="keyword"></font>
00067 <font class="keyword"></font>{
00068     assert( <font class="keyword">sizeof</font>(<font class="keywordtype">float</font>) == <font class="keyword">sizeof</font>(<font class="keywordtype">long</font>) );
00069     <font class="keywordtype">long</font> s = SwapLong( *((<font class="keywordtype">long</font> *)&amp;data) );
00070     <font class="keywordflow">return</font> *((<font class="keywordtype">float</font> *)&amp;s);
00071 }
00072 <font class="keyword">inline</font> <font class="keywordtype">double</font> SwapDouble( <font class="keywordtype">double</font> data )<font class="keyword"></font>
00073 <font class="keyword"></font>{
00074     assert( <font class="keyword">sizeof</font>(<font class="keywordtype">double</font>) == 2*<font class="keyword">sizeof</font>(<font class="keywordtype">long</font>) );
00075     <font class="keywordtype">char</font> *p  = (<font class="keywordtype">char</font> *)&amp;data;
00076     <font class="keywordtype">long</font>  l1 = *((<font class="keywordtype">long</font> *)( p + 0            )),
00077           l2 = *((<font class="keywordtype">long</font> *)( p + <font class="keyword">sizeof</font>(<font class="keywordtype">long</font>) ));
00078     *((<font class="keywordtype">long</font> *)( p + 0            )) = SwapLong( l2 );
00079     *((<font class="keywordtype">long</font> *)( p + <font class="keyword">sizeof</font>(<font class="keywordtype">long</font>) )) = SwapLong( l1 );
00080     <font class="keywordflow">return</font> data;
00081 }
00082 
00091 <font class="keyword">inline</font> <font class="keywordtype">short</font> SwapBytes( <font class="keywordtype">short</font>     data,
00092                         ByteOrder data_order,
00093                         ByteOrder desired_order )<font class="keyword"></font>
00094 <font class="keyword"></font>{
00095     <font class="keywordflow">if</font> ( data_order    == BO_MACHINE ) data_order    = NativeByteOrder();
00096     <font class="keywordflow">if</font> ( desired_order == BO_MACHINE ) desired_order = NativeByteOrder();
00097     <font class="keywordflow">if</font> ( data_order == desired_order )
00098         <font class="keywordflow">return</font> data;
00099     <font class="keywordflow">else</font>
00100         <font class="keywordflow">return</font> SwapShort( data );
00101 }
00102 
00103 <font class="keyword">inline</font> <font class="keywordtype">long</font> SwapBytes( <font class="keywordtype">long</font>      data,
00104                        ByteOrder data_order,
00105                        ByteOrder desired_order )<font class="keyword"></font>
00106 <font class="keyword"></font>{
00107     <font class="keywordflow">if</font> ( data_order    == BO_MACHINE ) data_order    = NativeByteOrder();
00108     <font class="keywordflow">if</font> ( desired_order == BO_MACHINE ) desired_order = NativeByteOrder();
00109     <font class="keywordflow">if</font> ( data_order == desired_order )
00110         <font class="keywordflow">return</font> data;
00111     <font class="keywordflow">else</font>
00112         <font class="keywordflow">return</font> SwapLong( data );
00113 }
00114 
00115 <font class="keyword">inline</font> <font class="keywordtype">int</font> SwapBytes( <font class="keywordtype">int</font>        data,
00116                       ByteOrder data_order,
00117                       ByteOrder desired_order )<font class="keyword"></font>
00118 <font class="keyword"></font>{
00119     <font class="keywordflow">if</font> ( data_order    == BO_MACHINE ) data_order    = NativeByteOrder();
00120     <font class="keywordflow">if</font> ( desired_order == BO_MACHINE ) desired_order = NativeByteOrder();
00121     <font class="keywordflow">if</font> ( data_order == desired_order )
00122         <font class="keywordflow">return</font> data;
00123     <font class="keywordflow">else</font>
00124         <font class="keywordflow">return</font> SwapInt( data );
00125 }
00126 
00127 <font class="keyword">inline</font> <font class="keywordtype">float</font> SwapBytes( <font class="keywordtype">float</font>     data,
00128                         ByteOrder data_order,
00129                         ByteOrder desired_order )<font class="keyword"></font>
00130 <font class="keyword"></font>{
00131     <font class="keywordflow">if</font> ( data_order    == BO_MACHINE ) data_order    = NativeByteOrder();
00132     <font class="keywordflow">if</font> ( desired_order == BO_MACHINE ) desired_order = NativeByteOrder();
00133     <font class="keywordflow">if</font> ( data_order == desired_order )
00134         <font class="keywordflow">return</font> data;
00135     <font class="keywordflow">else</font>
00136         <font class="keywordflow">return</font> SwapFloat( data );
00137 }
00138 
00139 <font class="keyword">inline</font> <font class="keywordtype">double</font> SwapBytes( <font class="keywordtype">double</font>    data,
00140                          ByteOrder data_order,
00141                          ByteOrder desired_order )<font class="keyword"></font>
00142 <font class="keyword"></font>{
00143     <font class="keywordflow">if</font> ( data_order    == BO_MACHINE ) data_order    = NativeByteOrder();
00144     <font class="keywordflow">if</font> ( desired_order == BO_MACHINE ) desired_order = NativeByteOrder();
00145     <font class="keywordflow">if</font> ( data_order == desired_order )
00146         <font class="keywordflow">return</font> data;
00147     <font class="keywordflow">else</font>
00148         <font class="keywordflow">return</font> SwapDouble( data );
00149 }
00150 
00163 <font class="keywordtype">void</font> SwapMemBytes( <font class="keywordtype">void</font> *items, DataType type, size_t count,
00164                    ByteOrder file_order, ByteOrder desired_order );
00165 
00179 size_t FRead( <font class="keywordtype">void</font> *ptr, DataType type, size_t nitems, FILE *stream,
00180               ByteOrder file_order, ByteOrder desired_order = BO_MACHINE );
00181 
00182 <font class="preprocessor">#endif</font>
</font></pre></div><hr><address><small>Generated at Sun Oct 7 23:42:35 2001 for vtdata library by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.9.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
